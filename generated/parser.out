Created by PLY version 3.7 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration_list
Rule 2     declaration_list -> declaration_list declaration
Rule 3     declaration_list -> declaration
Rule 4     declaration -> var_declaration
Rule 5     declaration -> fun_declaration
Rule 6     var_declaration -> type_specifier ID
Rule 7     fun_declaration -> type_specifier ID ( ) statement
Rule 8     statement -> expression_stmt
Rule 9     statement -> compound_stmt
Rule 10    statement -> return_stmt
Rule 11    expression_stmt -> expression ;
Rule 12    expression_stmt -> ;
Rule 13    compound_stmt -> { expression }
Rule 14    return_stmt -> RETURN ;
Rule 15    return_stmt -> RETURN expression ;
Rule 16    expression -> mutable = simple_expression
Rule 17    expression -> mutable = mutable
Rule 18    expression -> simple_expression
Rule 19    simple_expression -> mutable SUM_OP mutable
Rule 20    simple_expression -> mutable MUL_OP mutable
Rule 21    mutable -> ID
Rule 22    mutable -> NUMBER
Rule 23    type_specifier -> VOID
Rule 24    type_specifier -> INT
Rule 25    type_specifier -> FLOAT
Rule 26    type_specifier -> BOOL
Rule 27    type_specifier -> CHAR
Rule 28    statement -> SUM_OP statement

Terminals, with rules where they appear

(                    : 7
)                    : 7
;                    : 11 12 14 15
=                    : 16 17
BOOL                 : 26
CHAR                 : 27
FLOAT                : 25
ID                   : 6 7 21
INT                  : 24
MUL_OP               : 20
NUMBER               : 22
RETURN               : 14 15
SUM_OP               : 19 28
VOID                 : 23
error                : 
{                    : 13
}                    : 13

Nonterminals, with rules where they appear

compound_stmt        : 9
declaration          : 2 3
declaration_list     : 1 2
expression           : 11 13 15
expression_stmt      : 8
fun_declaration      : 5
mutable              : 16 17 17 19 19 20 20
program              : 0
return_stmt          : 10
simple_expression    : 16 18
statement            : 7 28
type_specifier       : 6 7
var_declaration      : 4

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration_list
    (2) declaration_list -> . declaration_list declaration
    (3) declaration_list -> . declaration
    (4) declaration -> . var_declaration
    (5) declaration -> . fun_declaration
    (6) var_declaration -> . type_specifier ID
    (7) fun_declaration -> . type_specifier ID ( ) statement
    (23) type_specifier -> . VOID
    (24) type_specifier -> . INT
    (25) type_specifier -> . FLOAT
    (26) type_specifier -> . BOOL
    (27) type_specifier -> . CHAR

    VOID            shift and go to state 3
    INT             shift and go to state 8
    FLOAT           shift and go to state 5
    BOOL            shift and go to state 2
    CHAR            shift and go to state 7

    declaration_list               shift and go to state 1
    program                        shift and go to state 6
    type_specifier                 shift and go to state 4
    declaration                    shift and go to state 9
    var_declaration                shift and go to state 11
    fun_declaration                shift and go to state 10

state 1

    (1) program -> declaration_list .
    (2) declaration_list -> declaration_list . declaration
    (4) declaration -> . var_declaration
    (5) declaration -> . fun_declaration
    (6) var_declaration -> . type_specifier ID
    (7) fun_declaration -> . type_specifier ID ( ) statement
    (23) type_specifier -> . VOID
    (24) type_specifier -> . INT
    (25) type_specifier -> . FLOAT
    (26) type_specifier -> . BOOL
    (27) type_specifier -> . CHAR

    $end            reduce using rule 1 (program -> declaration_list .)
    VOID            shift and go to state 3
    INT             shift and go to state 8
    FLOAT           shift and go to state 5
    BOOL            shift and go to state 2
    CHAR            shift and go to state 7

    type_specifier                 shift and go to state 4
    declaration                    shift and go to state 12
    var_declaration                shift and go to state 11
    fun_declaration                shift and go to state 10

state 2

    (26) type_specifier -> BOOL .

    ID              reduce using rule 26 (type_specifier -> BOOL .)


state 3

    (23) type_specifier -> VOID .

    ID              reduce using rule 23 (type_specifier -> VOID .)


state 4

    (6) var_declaration -> type_specifier . ID
    (7) fun_declaration -> type_specifier . ID ( ) statement

    ID              shift and go to state 13


state 5

    (25) type_specifier -> FLOAT .

    ID              reduce using rule 25 (type_specifier -> FLOAT .)


state 6

    (0) S' -> program .



state 7

    (27) type_specifier -> CHAR .

    ID              reduce using rule 27 (type_specifier -> CHAR .)


state 8

    (24) type_specifier -> INT .

    ID              reduce using rule 24 (type_specifier -> INT .)


state 9

    (3) declaration_list -> declaration .

    VOID            reduce using rule 3 (declaration_list -> declaration .)
    INT             reduce using rule 3 (declaration_list -> declaration .)
    FLOAT           reduce using rule 3 (declaration_list -> declaration .)
    BOOL            reduce using rule 3 (declaration_list -> declaration .)
    CHAR            reduce using rule 3 (declaration_list -> declaration .)
    $end            reduce using rule 3 (declaration_list -> declaration .)


state 10

    (5) declaration -> fun_declaration .

    VOID            reduce using rule 5 (declaration -> fun_declaration .)
    INT             reduce using rule 5 (declaration -> fun_declaration .)
    FLOAT           reduce using rule 5 (declaration -> fun_declaration .)
    BOOL            reduce using rule 5 (declaration -> fun_declaration .)
    CHAR            reduce using rule 5 (declaration -> fun_declaration .)
    $end            reduce using rule 5 (declaration -> fun_declaration .)


state 11

    (4) declaration -> var_declaration .

    VOID            reduce using rule 4 (declaration -> var_declaration .)
    INT             reduce using rule 4 (declaration -> var_declaration .)
    FLOAT           reduce using rule 4 (declaration -> var_declaration .)
    BOOL            reduce using rule 4 (declaration -> var_declaration .)
    CHAR            reduce using rule 4 (declaration -> var_declaration .)
    $end            reduce using rule 4 (declaration -> var_declaration .)


state 12

    (2) declaration_list -> declaration_list declaration .

    VOID            reduce using rule 2 (declaration_list -> declaration_list declaration .)
    INT             reduce using rule 2 (declaration_list -> declaration_list declaration .)
    FLOAT           reduce using rule 2 (declaration_list -> declaration_list declaration .)
    BOOL            reduce using rule 2 (declaration_list -> declaration_list declaration .)
    CHAR            reduce using rule 2 (declaration_list -> declaration_list declaration .)
    $end            reduce using rule 2 (declaration_list -> declaration_list declaration .)


state 13

    (6) var_declaration -> type_specifier ID .
    (7) fun_declaration -> type_specifier ID . ( ) statement

    VOID            reduce using rule 6 (var_declaration -> type_specifier ID .)
    INT             reduce using rule 6 (var_declaration -> type_specifier ID .)
    FLOAT           reduce using rule 6 (var_declaration -> type_specifier ID .)
    BOOL            reduce using rule 6 (var_declaration -> type_specifier ID .)
    CHAR            reduce using rule 6 (var_declaration -> type_specifier ID .)
    $end            reduce using rule 6 (var_declaration -> type_specifier ID .)
    (               shift and go to state 14


state 14

    (7) fun_declaration -> type_specifier ID ( . ) statement

    )               shift and go to state 15


state 15

    (7) fun_declaration -> type_specifier ID ( ) . statement
    (8) statement -> . expression_stmt
    (9) statement -> . compound_stmt
    (10) statement -> . return_stmt
    (28) statement -> . SUM_OP statement
    (11) expression_stmt -> . expression ;
    (12) expression_stmt -> . ;
    (13) compound_stmt -> . { expression }
    (14) return_stmt -> . RETURN ;
    (15) return_stmt -> . RETURN expression ;
    (16) expression -> . mutable = simple_expression
    (17) expression -> . mutable = mutable
    (18) expression -> . simple_expression
    (21) mutable -> . ID
    (22) mutable -> . NUMBER
    (19) simple_expression -> . mutable SUM_OP mutable
    (20) simple_expression -> . mutable MUL_OP mutable

    SUM_OP          shift and go to state 21
    ;               shift and go to state 26
    {               shift and go to state 19
    RETURN          shift and go to state 23
    ID              shift and go to state 18
    NUMBER          shift and go to state 22

    statement                      shift and go to state 16
    expression_stmt                shift and go to state 17
    return_stmt                    shift and go to state 24
    compound_stmt                  shift and go to state 25
    simple_expression              shift and go to state 20
    expression                     shift and go to state 27
    mutable                        shift and go to state 28

state 16

    (7) fun_declaration -> type_specifier ID ( ) statement .

    VOID            reduce using rule 7 (fun_declaration -> type_specifier ID ( ) statement .)
    INT             reduce using rule 7 (fun_declaration -> type_specifier ID ( ) statement .)
    FLOAT           reduce using rule 7 (fun_declaration -> type_specifier ID ( ) statement .)
    BOOL            reduce using rule 7 (fun_declaration -> type_specifier ID ( ) statement .)
    CHAR            reduce using rule 7 (fun_declaration -> type_specifier ID ( ) statement .)
    $end            reduce using rule 7 (fun_declaration -> type_specifier ID ( ) statement .)


state 17

    (8) statement -> expression_stmt .

    VOID            reduce using rule 8 (statement -> expression_stmt .)
    INT             reduce using rule 8 (statement -> expression_stmt .)
    FLOAT           reduce using rule 8 (statement -> expression_stmt .)
    BOOL            reduce using rule 8 (statement -> expression_stmt .)
    CHAR            reduce using rule 8 (statement -> expression_stmt .)
    $end            reduce using rule 8 (statement -> expression_stmt .)


state 18

    (21) mutable -> ID .

    =               reduce using rule 21 (mutable -> ID .)
    SUM_OP          reduce using rule 21 (mutable -> ID .)
    MUL_OP          reduce using rule 21 (mutable -> ID .)
    ;               reduce using rule 21 (mutable -> ID .)
    }               reduce using rule 21 (mutable -> ID .)


state 19

    (13) compound_stmt -> { . expression }
    (16) expression -> . mutable = simple_expression
    (17) expression -> . mutable = mutable
    (18) expression -> . simple_expression
    (21) mutable -> . ID
    (22) mutable -> . NUMBER
    (19) simple_expression -> . mutable SUM_OP mutable
    (20) simple_expression -> . mutable MUL_OP mutable

    ID              shift and go to state 18
    NUMBER          shift and go to state 22

    expression                     shift and go to state 29
    simple_expression              shift and go to state 20
    mutable                        shift and go to state 28

state 20

    (18) expression -> simple_expression .

    ;               reduce using rule 18 (expression -> simple_expression .)
    }               reduce using rule 18 (expression -> simple_expression .)


state 21

    (28) statement -> SUM_OP . statement
    (8) statement -> . expression_stmt
    (9) statement -> . compound_stmt
    (10) statement -> . return_stmt
    (28) statement -> . SUM_OP statement
    (11) expression_stmt -> . expression ;
    (12) expression_stmt -> . ;
    (13) compound_stmt -> . { expression }
    (14) return_stmt -> . RETURN ;
    (15) return_stmt -> . RETURN expression ;
    (16) expression -> . mutable = simple_expression
    (17) expression -> . mutable = mutable
    (18) expression -> . simple_expression
    (21) mutable -> . ID
    (22) mutable -> . NUMBER
    (19) simple_expression -> . mutable SUM_OP mutable
    (20) simple_expression -> . mutable MUL_OP mutable

    SUM_OP          shift and go to state 21
    ;               shift and go to state 26
    {               shift and go to state 19
    RETURN          shift and go to state 23
    ID              shift and go to state 18
    NUMBER          shift and go to state 22

    statement                      shift and go to state 30
    expression_stmt                shift and go to state 17
    expression                     shift and go to state 27
    compound_stmt                  shift and go to state 25
    simple_expression              shift and go to state 20
    return_stmt                    shift and go to state 24
    mutable                        shift and go to state 28

state 22

    (22) mutable -> NUMBER .

    =               reduce using rule 22 (mutable -> NUMBER .)
    SUM_OP          reduce using rule 22 (mutable -> NUMBER .)
    MUL_OP          reduce using rule 22 (mutable -> NUMBER .)
    ;               reduce using rule 22 (mutable -> NUMBER .)
    }               reduce using rule 22 (mutable -> NUMBER .)


state 23

    (14) return_stmt -> RETURN . ;
    (15) return_stmt -> RETURN . expression ;
    (16) expression -> . mutable = simple_expression
    (17) expression -> . mutable = mutable
    (18) expression -> . simple_expression
    (21) mutable -> . ID
    (22) mutable -> . NUMBER
    (19) simple_expression -> . mutable SUM_OP mutable
    (20) simple_expression -> . mutable MUL_OP mutable

    ;               shift and go to state 32
    ID              shift and go to state 18
    NUMBER          shift and go to state 22

    expression                     shift and go to state 31
    simple_expression              shift and go to state 20
    mutable                        shift and go to state 28

state 24

    (10) statement -> return_stmt .

    VOID            reduce using rule 10 (statement -> return_stmt .)
    INT             reduce using rule 10 (statement -> return_stmt .)
    FLOAT           reduce using rule 10 (statement -> return_stmt .)
    BOOL            reduce using rule 10 (statement -> return_stmt .)
    CHAR            reduce using rule 10 (statement -> return_stmt .)
    $end            reduce using rule 10 (statement -> return_stmt .)


state 25

    (9) statement -> compound_stmt .

    VOID            reduce using rule 9 (statement -> compound_stmt .)
    INT             reduce using rule 9 (statement -> compound_stmt .)
    FLOAT           reduce using rule 9 (statement -> compound_stmt .)
    BOOL            reduce using rule 9 (statement -> compound_stmt .)
    CHAR            reduce using rule 9 (statement -> compound_stmt .)
    $end            reduce using rule 9 (statement -> compound_stmt .)


state 26

    (12) expression_stmt -> ; .

    VOID            reduce using rule 12 (expression_stmt -> ; .)
    INT             reduce using rule 12 (expression_stmt -> ; .)
    FLOAT           reduce using rule 12 (expression_stmt -> ; .)
    BOOL            reduce using rule 12 (expression_stmt -> ; .)
    CHAR            reduce using rule 12 (expression_stmt -> ; .)
    $end            reduce using rule 12 (expression_stmt -> ; .)


state 27

    (11) expression_stmt -> expression . ;

    ;               shift and go to state 33


state 28

    (16) expression -> mutable . = simple_expression
    (17) expression -> mutable . = mutable
    (19) simple_expression -> mutable . SUM_OP mutable
    (20) simple_expression -> mutable . MUL_OP mutable

    =               shift and go to state 35
    SUM_OP          shift and go to state 34
    MUL_OP          shift and go to state 36


state 29

    (13) compound_stmt -> { expression . }

    }               shift and go to state 37


state 30

    (28) statement -> SUM_OP statement .

    VOID            reduce using rule 28 (statement -> SUM_OP statement .)
    INT             reduce using rule 28 (statement -> SUM_OP statement .)
    FLOAT           reduce using rule 28 (statement -> SUM_OP statement .)
    BOOL            reduce using rule 28 (statement -> SUM_OP statement .)
    CHAR            reduce using rule 28 (statement -> SUM_OP statement .)
    $end            reduce using rule 28 (statement -> SUM_OP statement .)


state 31

    (15) return_stmt -> RETURN expression . ;

    ;               shift and go to state 38


state 32

    (14) return_stmt -> RETURN ; .

    VOID            reduce using rule 14 (return_stmt -> RETURN ; .)
    INT             reduce using rule 14 (return_stmt -> RETURN ; .)
    FLOAT           reduce using rule 14 (return_stmt -> RETURN ; .)
    BOOL            reduce using rule 14 (return_stmt -> RETURN ; .)
    CHAR            reduce using rule 14 (return_stmt -> RETURN ; .)
    $end            reduce using rule 14 (return_stmt -> RETURN ; .)


state 33

    (11) expression_stmt -> expression ; .

    VOID            reduce using rule 11 (expression_stmt -> expression ; .)
    INT             reduce using rule 11 (expression_stmt -> expression ; .)
    FLOAT           reduce using rule 11 (expression_stmt -> expression ; .)
    BOOL            reduce using rule 11 (expression_stmt -> expression ; .)
    CHAR            reduce using rule 11 (expression_stmt -> expression ; .)
    $end            reduce using rule 11 (expression_stmt -> expression ; .)


state 34

    (19) simple_expression -> mutable SUM_OP . mutable
    (21) mutable -> . ID
    (22) mutable -> . NUMBER

    ID              shift and go to state 18
    NUMBER          shift and go to state 22

    mutable                        shift and go to state 39

state 35

    (16) expression -> mutable = . simple_expression
    (17) expression -> mutable = . mutable
    (19) simple_expression -> . mutable SUM_OP mutable
    (20) simple_expression -> . mutable MUL_OP mutable
    (21) mutable -> . ID
    (22) mutable -> . NUMBER

    ID              shift and go to state 18
    NUMBER          shift and go to state 22

    simple_expression              shift and go to state 40
    mutable                        shift and go to state 41

state 36

    (20) simple_expression -> mutable MUL_OP . mutable
    (21) mutable -> . ID
    (22) mutable -> . NUMBER

    ID              shift and go to state 18
    NUMBER          shift and go to state 22

    mutable                        shift and go to state 42

state 37

    (13) compound_stmt -> { expression } .

    VOID            reduce using rule 13 (compound_stmt -> { expression } .)
    INT             reduce using rule 13 (compound_stmt -> { expression } .)
    FLOAT           reduce using rule 13 (compound_stmt -> { expression } .)
    BOOL            reduce using rule 13 (compound_stmt -> { expression } .)
    CHAR            reduce using rule 13 (compound_stmt -> { expression } .)
    $end            reduce using rule 13 (compound_stmt -> { expression } .)


state 38

    (15) return_stmt -> RETURN expression ; .

    VOID            reduce using rule 15 (return_stmt -> RETURN expression ; .)
    INT             reduce using rule 15 (return_stmt -> RETURN expression ; .)
    FLOAT           reduce using rule 15 (return_stmt -> RETURN expression ; .)
    BOOL            reduce using rule 15 (return_stmt -> RETURN expression ; .)
    CHAR            reduce using rule 15 (return_stmt -> RETURN expression ; .)
    $end            reduce using rule 15 (return_stmt -> RETURN expression ; .)


state 39

    (19) simple_expression -> mutable SUM_OP mutable .

    ;               reduce using rule 19 (simple_expression -> mutable SUM_OP mutable .)
    }               reduce using rule 19 (simple_expression -> mutable SUM_OP mutable .)


state 40

    (16) expression -> mutable = simple_expression .

    ;               reduce using rule 16 (expression -> mutable = simple_expression .)
    }               reduce using rule 16 (expression -> mutable = simple_expression .)


state 41

    (17) expression -> mutable = mutable .
    (19) simple_expression -> mutable . SUM_OP mutable
    (20) simple_expression -> mutable . MUL_OP mutable

    ;               reduce using rule 17 (expression -> mutable = mutable .)
    }               reduce using rule 17 (expression -> mutable = mutable .)
    SUM_OP          shift and go to state 34
    MUL_OP          shift and go to state 36


state 42

    (20) simple_expression -> mutable MUL_OP mutable .

    ;               reduce using rule 20 (simple_expression -> mutable MUL_OP mutable .)
    }               reduce using rule 20 (simple_expression -> mutable MUL_OP mutable .)

