Created by PLY version 3.7 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> declaration_list
Rule 2     declaration_list -> declaration_list declaration
Rule 3     declaration_list -> declaration
Rule 4     declaration -> var_declaration
Rule 5     declaration -> fun_declaration
Rule 6     var_declaration -> type_specifier ID
Rule 7     fun_declaration -> type_specifier ID ( ) statement
Rule 8     statement -> expression_stmt
Rule 9     statement -> compound_stmt
Rule 10    statement -> return_stmt
Rule 11    expression_stmt -> expression ;
Rule 12    expression_stmt -> ;
Rule 13    compound_stmt -> { expression }
Rule 14    return_stmt -> RETURN ;
Rule 15    return_stmt -> RETURN expression ;
Rule 16    expression -> mutable = simple_expression
Rule 17    expression -> mutable = mutable
Rule 18    expression -> mutable = call
Rule 19    expression -> simple_expression
Rule 20    simple_expression -> mutable SUM_OP mutable
Rule 21    simple_expression -> mutable MUL_OP mutable
Rule 22    call -> ID ( )
Rule 23    mutable -> ID
Rule 24    mutable -> NUMBER
Rule 25    type_specifier -> VOID
Rule 26    type_specifier -> INT
Rule 27    type_specifier -> FLOAT
Rule 28    type_specifier -> BOOL
Rule 29    type_specifier -> CHAR
Rule 30    statement -> SUM_OP statement

Terminals, with rules where they appear

(                    : 7 22
)                    : 7 22
;                    : 11 12 14 15
=                    : 16 17 18
BOOL                 : 28
CHAR                 : 29
FLOAT                : 27
ID                   : 6 7 22 23
INT                  : 26
MUL_OP               : 21
NUMBER               : 24
RETURN               : 14 15
SUM_OP               : 20 30
VOID                 : 25
error                : 
{                    : 13
}                    : 13

Nonterminals, with rules where they appear

call                 : 18
compound_stmt        : 9
declaration          : 2 3
declaration_list     : 1 2
expression           : 11 13 15
expression_stmt      : 8
fun_declaration      : 5
mutable              : 16 17 17 18 20 20 21 21
program              : 0
return_stmt          : 10
simple_expression    : 16 19
statement            : 7 30
type_specifier       : 6 7
var_declaration      : 4

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . declaration_list
    (2) declaration_list -> . declaration_list declaration
    (3) declaration_list -> . declaration
    (4) declaration -> . var_declaration
    (5) declaration -> . fun_declaration
    (6) var_declaration -> . type_specifier ID
    (7) fun_declaration -> . type_specifier ID ( ) statement
    (25) type_specifier -> . VOID
    (26) type_specifier -> . INT
    (27) type_specifier -> . FLOAT
    (28) type_specifier -> . BOOL
    (29) type_specifier -> . CHAR

    VOID            shift and go to state 11
    INT             shift and go to state 6
    FLOAT           shift and go to state 7
    BOOL            shift and go to state 1
    CHAR            shift and go to state 3

    declaration                    shift and go to state 8
    fun_declaration                shift and go to state 9
    type_specifier                 shift and go to state 10
    program                        shift and go to state 4
    var_declaration                shift and go to state 2
    declaration_list               shift and go to state 5

state 1

    (28) type_specifier -> BOOL .

    ID              reduce using rule 28 (type_specifier -> BOOL .)


state 2

    (4) declaration -> var_declaration .

    VOID            reduce using rule 4 (declaration -> var_declaration .)
    INT             reduce using rule 4 (declaration -> var_declaration .)
    FLOAT           reduce using rule 4 (declaration -> var_declaration .)
    BOOL            reduce using rule 4 (declaration -> var_declaration .)
    CHAR            reduce using rule 4 (declaration -> var_declaration .)
    $end            reduce using rule 4 (declaration -> var_declaration .)


state 3

    (29) type_specifier -> CHAR .

    ID              reduce using rule 29 (type_specifier -> CHAR .)


state 4

    (0) S' -> program .



state 5

    (1) program -> declaration_list .
    (2) declaration_list -> declaration_list . declaration
    (4) declaration -> . var_declaration
    (5) declaration -> . fun_declaration
    (6) var_declaration -> . type_specifier ID
    (7) fun_declaration -> . type_specifier ID ( ) statement
    (25) type_specifier -> . VOID
    (26) type_specifier -> . INT
    (27) type_specifier -> . FLOAT
    (28) type_specifier -> . BOOL
    (29) type_specifier -> . CHAR

    $end            reduce using rule 1 (program -> declaration_list .)
    VOID            shift and go to state 11
    INT             shift and go to state 6
    FLOAT           shift and go to state 7
    BOOL            shift and go to state 1
    CHAR            shift and go to state 3

    declaration                    shift and go to state 12
    fun_declaration                shift and go to state 9
    type_specifier                 shift and go to state 10
    var_declaration                shift and go to state 2

state 6

    (26) type_specifier -> INT .

    ID              reduce using rule 26 (type_specifier -> INT .)


state 7

    (27) type_specifier -> FLOAT .

    ID              reduce using rule 27 (type_specifier -> FLOAT .)


state 8

    (3) declaration_list -> declaration .

    VOID            reduce using rule 3 (declaration_list -> declaration .)
    INT             reduce using rule 3 (declaration_list -> declaration .)
    FLOAT           reduce using rule 3 (declaration_list -> declaration .)
    BOOL            reduce using rule 3 (declaration_list -> declaration .)
    CHAR            reduce using rule 3 (declaration_list -> declaration .)
    $end            reduce using rule 3 (declaration_list -> declaration .)


state 9

    (5) declaration -> fun_declaration .

    VOID            reduce using rule 5 (declaration -> fun_declaration .)
    INT             reduce using rule 5 (declaration -> fun_declaration .)
    FLOAT           reduce using rule 5 (declaration -> fun_declaration .)
    BOOL            reduce using rule 5 (declaration -> fun_declaration .)
    CHAR            reduce using rule 5 (declaration -> fun_declaration .)
    $end            reduce using rule 5 (declaration -> fun_declaration .)


state 10

    (6) var_declaration -> type_specifier . ID
    (7) fun_declaration -> type_specifier . ID ( ) statement

    ID              shift and go to state 13


state 11

    (25) type_specifier -> VOID .

    ID              reduce using rule 25 (type_specifier -> VOID .)


state 12

    (2) declaration_list -> declaration_list declaration .

    VOID            reduce using rule 2 (declaration_list -> declaration_list declaration .)
    INT             reduce using rule 2 (declaration_list -> declaration_list declaration .)
    FLOAT           reduce using rule 2 (declaration_list -> declaration_list declaration .)
    BOOL            reduce using rule 2 (declaration_list -> declaration_list declaration .)
    CHAR            reduce using rule 2 (declaration_list -> declaration_list declaration .)
    $end            reduce using rule 2 (declaration_list -> declaration_list declaration .)


state 13

    (6) var_declaration -> type_specifier ID .
    (7) fun_declaration -> type_specifier ID . ( ) statement

    VOID            reduce using rule 6 (var_declaration -> type_specifier ID .)
    INT             reduce using rule 6 (var_declaration -> type_specifier ID .)
    FLOAT           reduce using rule 6 (var_declaration -> type_specifier ID .)
    BOOL            reduce using rule 6 (var_declaration -> type_specifier ID .)
    CHAR            reduce using rule 6 (var_declaration -> type_specifier ID .)
    $end            reduce using rule 6 (var_declaration -> type_specifier ID .)
    (               shift and go to state 14


state 14

    (7) fun_declaration -> type_specifier ID ( . ) statement

    )               shift and go to state 15


state 15

    (7) fun_declaration -> type_specifier ID ( ) . statement
    (8) statement -> . expression_stmt
    (9) statement -> . compound_stmt
    (10) statement -> . return_stmt
    (30) statement -> . SUM_OP statement
    (11) expression_stmt -> . expression ;
    (12) expression_stmt -> . ;
    (13) compound_stmt -> . { expression }
    (14) return_stmt -> . RETURN ;
    (15) return_stmt -> . RETURN expression ;
    (16) expression -> . mutable = simple_expression
    (17) expression -> . mutable = mutable
    (18) expression -> . mutable = call
    (19) expression -> . simple_expression
    (23) mutable -> . ID
    (24) mutable -> . NUMBER
    (20) simple_expression -> . mutable SUM_OP mutable
    (21) simple_expression -> . mutable MUL_OP mutable

    SUM_OP          shift and go to state 26
    ;               shift and go to state 20
    {               shift and go to state 27
    RETURN          shift and go to state 18
    ID              shift and go to state 24
    NUMBER          shift and go to state 23

    expression_stmt                shift and go to state 21
    statement                      shift and go to state 22
    return_stmt                    shift and go to state 16
    compound_stmt                  shift and go to state 19
    expression                     shift and go to state 25
    mutable                        shift and go to state 17
    simple_expression              shift and go to state 28

state 16

    (10) statement -> return_stmt .

    VOID            reduce using rule 10 (statement -> return_stmt .)
    INT             reduce using rule 10 (statement -> return_stmt .)
    FLOAT           reduce using rule 10 (statement -> return_stmt .)
    BOOL            reduce using rule 10 (statement -> return_stmt .)
    CHAR            reduce using rule 10 (statement -> return_stmt .)
    $end            reduce using rule 10 (statement -> return_stmt .)


state 17

    (16) expression -> mutable . = simple_expression
    (17) expression -> mutable . = mutable
    (18) expression -> mutable . = call
    (20) simple_expression -> mutable . SUM_OP mutable
    (21) simple_expression -> mutable . MUL_OP mutable

    =               shift and go to state 30
    SUM_OP          shift and go to state 31
    MUL_OP          shift and go to state 29


state 18

    (14) return_stmt -> RETURN . ;
    (15) return_stmt -> RETURN . expression ;
    (16) expression -> . mutable = simple_expression
    (17) expression -> . mutable = mutable
    (18) expression -> . mutable = call
    (19) expression -> . simple_expression
    (23) mutable -> . ID
    (24) mutable -> . NUMBER
    (20) simple_expression -> . mutable SUM_OP mutable
    (21) simple_expression -> . mutable MUL_OP mutable

    ;               shift and go to state 33
    ID              shift and go to state 24
    NUMBER          shift and go to state 23

    expression                     shift and go to state 32
    mutable                        shift and go to state 17
    simple_expression              shift and go to state 28

state 19

    (9) statement -> compound_stmt .

    VOID            reduce using rule 9 (statement -> compound_stmt .)
    INT             reduce using rule 9 (statement -> compound_stmt .)
    FLOAT           reduce using rule 9 (statement -> compound_stmt .)
    BOOL            reduce using rule 9 (statement -> compound_stmt .)
    CHAR            reduce using rule 9 (statement -> compound_stmt .)
    $end            reduce using rule 9 (statement -> compound_stmt .)


state 20

    (12) expression_stmt -> ; .

    VOID            reduce using rule 12 (expression_stmt -> ; .)
    INT             reduce using rule 12 (expression_stmt -> ; .)
    FLOAT           reduce using rule 12 (expression_stmt -> ; .)
    BOOL            reduce using rule 12 (expression_stmt -> ; .)
    CHAR            reduce using rule 12 (expression_stmt -> ; .)
    $end            reduce using rule 12 (expression_stmt -> ; .)


state 21

    (8) statement -> expression_stmt .

    VOID            reduce using rule 8 (statement -> expression_stmt .)
    INT             reduce using rule 8 (statement -> expression_stmt .)
    FLOAT           reduce using rule 8 (statement -> expression_stmt .)
    BOOL            reduce using rule 8 (statement -> expression_stmt .)
    CHAR            reduce using rule 8 (statement -> expression_stmt .)
    $end            reduce using rule 8 (statement -> expression_stmt .)


state 22

    (7) fun_declaration -> type_specifier ID ( ) statement .

    VOID            reduce using rule 7 (fun_declaration -> type_specifier ID ( ) statement .)
    INT             reduce using rule 7 (fun_declaration -> type_specifier ID ( ) statement .)
    FLOAT           reduce using rule 7 (fun_declaration -> type_specifier ID ( ) statement .)
    BOOL            reduce using rule 7 (fun_declaration -> type_specifier ID ( ) statement .)
    CHAR            reduce using rule 7 (fun_declaration -> type_specifier ID ( ) statement .)
    $end            reduce using rule 7 (fun_declaration -> type_specifier ID ( ) statement .)


state 23

    (24) mutable -> NUMBER .

    =               reduce using rule 24 (mutable -> NUMBER .)
    SUM_OP          reduce using rule 24 (mutable -> NUMBER .)
    MUL_OP          reduce using rule 24 (mutable -> NUMBER .)
    ;               reduce using rule 24 (mutable -> NUMBER .)
    }               reduce using rule 24 (mutable -> NUMBER .)


state 24

    (23) mutable -> ID .

    =               reduce using rule 23 (mutable -> ID .)
    SUM_OP          reduce using rule 23 (mutable -> ID .)
    MUL_OP          reduce using rule 23 (mutable -> ID .)
    ;               reduce using rule 23 (mutable -> ID .)
    }               reduce using rule 23 (mutable -> ID .)


state 25

    (11) expression_stmt -> expression . ;

    ;               shift and go to state 34


state 26

    (30) statement -> SUM_OP . statement
    (8) statement -> . expression_stmt
    (9) statement -> . compound_stmt
    (10) statement -> . return_stmt
    (30) statement -> . SUM_OP statement
    (11) expression_stmt -> . expression ;
    (12) expression_stmt -> . ;
    (13) compound_stmt -> . { expression }
    (14) return_stmt -> . RETURN ;
    (15) return_stmt -> . RETURN expression ;
    (16) expression -> . mutable = simple_expression
    (17) expression -> . mutable = mutable
    (18) expression -> . mutable = call
    (19) expression -> . simple_expression
    (23) mutable -> . ID
    (24) mutable -> . NUMBER
    (20) simple_expression -> . mutable SUM_OP mutable
    (21) simple_expression -> . mutable MUL_OP mutable

    SUM_OP          shift and go to state 26
    ;               shift and go to state 20
    {               shift and go to state 27
    RETURN          shift and go to state 18
    ID              shift and go to state 24
    NUMBER          shift and go to state 23

    expression_stmt                shift and go to state 21
    statement                      shift and go to state 35
    return_stmt                    shift and go to state 16
    compound_stmt                  shift and go to state 19
    expression                     shift and go to state 25
    mutable                        shift and go to state 17
    simple_expression              shift and go to state 28

state 27

    (13) compound_stmt -> { . expression }
    (16) expression -> . mutable = simple_expression
    (17) expression -> . mutable = mutable
    (18) expression -> . mutable = call
    (19) expression -> . simple_expression
    (23) mutable -> . ID
    (24) mutable -> . NUMBER
    (20) simple_expression -> . mutable SUM_OP mutable
    (21) simple_expression -> . mutable MUL_OP mutable

    ID              shift and go to state 24
    NUMBER          shift and go to state 23

    expression                     shift and go to state 36
    mutable                        shift and go to state 17
    simple_expression              shift and go to state 28

state 28

    (19) expression -> simple_expression .

    }               reduce using rule 19 (expression -> simple_expression .)
    ;               reduce using rule 19 (expression -> simple_expression .)


state 29

    (21) simple_expression -> mutable MUL_OP . mutable
    (23) mutable -> . ID
    (24) mutable -> . NUMBER

    ID              shift and go to state 24
    NUMBER          shift and go to state 23

    mutable                        shift and go to state 37

state 30

    (16) expression -> mutable = . simple_expression
    (17) expression -> mutable = . mutable
    (18) expression -> mutable = . call
    (20) simple_expression -> . mutable SUM_OP mutable
    (21) simple_expression -> . mutable MUL_OP mutable
    (23) mutable -> . ID
    (24) mutable -> . NUMBER
    (22) call -> . ID ( )

    ID              shift and go to state 39
    NUMBER          shift and go to state 23

    call                           shift and go to state 38
    mutable                        shift and go to state 40
    simple_expression              shift and go to state 41

state 31

    (20) simple_expression -> mutable SUM_OP . mutable
    (23) mutable -> . ID
    (24) mutable -> . NUMBER

    ID              shift and go to state 24
    NUMBER          shift and go to state 23

    mutable                        shift and go to state 42

state 32

    (15) return_stmt -> RETURN expression . ;

    ;               shift and go to state 43


state 33

    (14) return_stmt -> RETURN ; .

    VOID            reduce using rule 14 (return_stmt -> RETURN ; .)
    INT             reduce using rule 14 (return_stmt -> RETURN ; .)
    FLOAT           reduce using rule 14 (return_stmt -> RETURN ; .)
    BOOL            reduce using rule 14 (return_stmt -> RETURN ; .)
    CHAR            reduce using rule 14 (return_stmt -> RETURN ; .)
    $end            reduce using rule 14 (return_stmt -> RETURN ; .)


state 34

    (11) expression_stmt -> expression ; .

    VOID            reduce using rule 11 (expression_stmt -> expression ; .)
    INT             reduce using rule 11 (expression_stmt -> expression ; .)
    FLOAT           reduce using rule 11 (expression_stmt -> expression ; .)
    BOOL            reduce using rule 11 (expression_stmt -> expression ; .)
    CHAR            reduce using rule 11 (expression_stmt -> expression ; .)
    $end            reduce using rule 11 (expression_stmt -> expression ; .)


state 35

    (30) statement -> SUM_OP statement .

    VOID            reduce using rule 30 (statement -> SUM_OP statement .)
    INT             reduce using rule 30 (statement -> SUM_OP statement .)
    FLOAT           reduce using rule 30 (statement -> SUM_OP statement .)
    BOOL            reduce using rule 30 (statement -> SUM_OP statement .)
    CHAR            reduce using rule 30 (statement -> SUM_OP statement .)
    $end            reduce using rule 30 (statement -> SUM_OP statement .)


state 36

    (13) compound_stmt -> { expression . }

    }               shift and go to state 44


state 37

    (21) simple_expression -> mutable MUL_OP mutable .

    ;               reduce using rule 21 (simple_expression -> mutable MUL_OP mutable .)
    }               reduce using rule 21 (simple_expression -> mutable MUL_OP mutable .)


state 38

    (18) expression -> mutable = call .

    }               reduce using rule 18 (expression -> mutable = call .)
    ;               reduce using rule 18 (expression -> mutable = call .)


state 39

    (23) mutable -> ID .
    (22) call -> ID . ( )

    SUM_OP          reduce using rule 23 (mutable -> ID .)
    MUL_OP          reduce using rule 23 (mutable -> ID .)
    ;               reduce using rule 23 (mutable -> ID .)
    }               reduce using rule 23 (mutable -> ID .)
    (               shift and go to state 45


state 40

    (17) expression -> mutable = mutable .
    (20) simple_expression -> mutable . SUM_OP mutable
    (21) simple_expression -> mutable . MUL_OP mutable

    }               reduce using rule 17 (expression -> mutable = mutable .)
    ;               reduce using rule 17 (expression -> mutable = mutable .)
    SUM_OP          shift and go to state 31
    MUL_OP          shift and go to state 29


state 41

    (16) expression -> mutable = simple_expression .

    }               reduce using rule 16 (expression -> mutable = simple_expression .)
    ;               reduce using rule 16 (expression -> mutable = simple_expression .)


state 42

    (20) simple_expression -> mutable SUM_OP mutable .

    ;               reduce using rule 20 (simple_expression -> mutable SUM_OP mutable .)
    }               reduce using rule 20 (simple_expression -> mutable SUM_OP mutable .)


state 43

    (15) return_stmt -> RETURN expression ; .

    VOID            reduce using rule 15 (return_stmt -> RETURN expression ; .)
    INT             reduce using rule 15 (return_stmt -> RETURN expression ; .)
    FLOAT           reduce using rule 15 (return_stmt -> RETURN expression ; .)
    BOOL            reduce using rule 15 (return_stmt -> RETURN expression ; .)
    CHAR            reduce using rule 15 (return_stmt -> RETURN expression ; .)
    $end            reduce using rule 15 (return_stmt -> RETURN expression ; .)


state 44

    (13) compound_stmt -> { expression } .

    VOID            reduce using rule 13 (compound_stmt -> { expression } .)
    INT             reduce using rule 13 (compound_stmt -> { expression } .)
    FLOAT           reduce using rule 13 (compound_stmt -> { expression } .)
    BOOL            reduce using rule 13 (compound_stmt -> { expression } .)
    CHAR            reduce using rule 13 (compound_stmt -> { expression } .)
    $end            reduce using rule 13 (compound_stmt -> { expression } .)


state 45

    (22) call -> ID ( . )

    )               shift and go to state 46


state 46

    (22) call -> ID ( ) .

    ;               reduce using rule 22 (call -> ID ( ) .)
    }               reduce using rule 22 (call -> ID ( ) .)

